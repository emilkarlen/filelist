#! /usr/bin/python3
# -*- python -*-
# -*- coding: utf-8 -*-

###############################################################################
# Copyright 2014 Emil Karlén.
# 
# This file is part of file-name-resolver.
# 
# Wilde is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Wilde is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Wilde.  If not, see <http://www.gnu.org/licenses/>.
###############################################################################


###############################################################################
# - parse arguments -
###############################################################################


from types import FunctionType

import sys
import os
import argparse
import re
import textwrap
import fnmatch
import stat

EXIT_USAGE = 2
EXIT_INVALID_ARGUMENTS = 3
EXIT_SYNTAX = 4
EXIT_FILE_DOES_NOT_EXIST = 8 + 0


###############################################################################
# - utilities -
###############################################################################


debugEnabled = True


def debug(s):
    if debugEnabled:
        sys.stderr.write("DEBUG: " + s)
        sys.stderr.write(os.linesep)


def debug_q(s):
    debug("\"" + s + "\"")


def debug_begin(s):
    debug(s + " BEGIN")


def debug_end(s):
    debug(s + " END")


def cq(s):
    return " : \"" + s + "\""


def debug_cq(header, content):
    c = content
    if type(c) != str:
        c = str(c)
    debug(header + ":  `" + c + "'")


def write_lines(o_stream,lines):
    """Writes a list of lines with an added trailing newline, to a stream."""
    for line in lines:
        o_stream.write(line)
        o_stream.write(os.linesep)


###############################################################################
# - matcher utils -
###############################################################################


def or_matcher(matchers: list):
    """
    A matcher that must match one of a given list of matchers.
    """
    def f(x) -> bool:
        for matcher in matchers:
            if matcher(x):
                return True
        return False
    return f


def and_matcher(matchers: list):
    """
    A matcher that must match every one of a given list of matchers.
    """
    def f(x) -> bool:
        for matcher in matchers:
            if not matcher(x):
                return False
        return True
    return f


def constantly_true_matcher():
    def f(x) -> bool:
        return True
    return f


###############################################################################
# - classes -
###############################################################################


class Environment:
    """
    Environment for executing instructions.
    """

    def __init__(self,
                 from_curr_dir: str,
                 from_top_level_file: str):
        self.fromCurrDir = from_curr_dir
        self.fromTopLevelFile = from_top_level_file

    def new_for_directory(self, name_of_directory):
        if name_of_directory == ".":
            return self
        else:
            return self._append_dir(name_of_directory)

    def new_for_included_file(self, file_name_relative_include_file):
        dir_delta = os.path.dirname(file_name_relative_include_file)
        if not dir_delta:  # file is in same directory
            return self
        return self._append_dir(dir_delta)

    def file_name_relative_current_dir_of_process(self, file_name):
        return self.fromCurrDir + file_name

    def file_name_relative_top_level_source_file(self, file_name):
        return self.fromTopLevelFile + file_name

    def _append_dir(self, dir_delta):
        if dir_delta[-1] != os.path.sep:
            dir_delta += os.path.sep
        return Environment(
            os.path.join(self.fromCurrDir,
                         dir_delta),
            os.path.join(self.fromTopLevelFile,
                         dir_delta))


###############################################################################
# - ResultItem:s -
###############################################################################


class RenditionSettings:
    """
    Settings for rendering the output.
    """
    def __init__(self,
                 file_names_are_relative_file_argument_location: bool):
        """
        :rtype : RenditionSettings
        """
        self.file_names_are_relative_file_argument_location = file_names_are_relative_file_argument_location


class RenditionEnvironment(Environment):
    """
    Environment used during the rendition of a ResultItem.
    """

    @staticmethod
    def for_top_level_file(file_name: str,
                           settings: RenditionSettings):
        prefix = os.path.dirname(file_name)
        if prefix:
            prefix = prefix + os.sep
        return RenditionEnvironment(prefix,
                                    '',
                                    settings)

    def __init__(self,
                 from_curr_dir: str,
                 from_top_level_file: str,
                 rendition_settings: RenditionSettings):
        Environment.__init__(self,
                             from_curr_dir,
                             from_top_level_file)
        self.rendition_settings = rendition_settings

    def render_file_name_according_to_settings(self, file_name) -> str:
        if self.rendition_settings.file_names_are_relative_file_argument_location:
            return self.file_name_relative_top_level_source_file(file_name)
        else:
            return self.file_name_relative_current_dir_of_process(file_name)


class ResultItem:
    """
    An item in a successful result, ready for rendering.

    The rendering is not allowed to raise exceptions related to
    the instruction that constructs this object.  I.e., all checks
    and parses must be done.
    """

    def render(self,
               env: RenditionEnvironment):
        """
        Renders the item as a string).

        Not allowed to raise exceptions (except for implementation issues,
        of course).
        """
        raise NotImplementedError()


class ParsingSettings:
    def __init__(self,
                 instruction_parsers_dict: dict):
        """
        :param instruction_parsers_dict: Maps instruction identifiers to
         parsers: str -> InstructionArgumentParser.
        """
        self.instruction_parsers_dict = instruction_parsers_dict

    def parserForInstruction(self,
                             identifier: str):
        return self.instruction_parsers_dict[identifier]


class ResultItemsConstructor:
    """An iterable of ResultItem:s."""

    def result_item_iterable(self,
                             parsing_settings: ParsingSettings,
                             env: Environment):
        """
        Gives an iterable of all ResultItem:s that this object represents.

        Can raise exceptions related to parsing and file checking.
        """
        raise NotImplementedError()


###############################################################################
# - concrete ResultItem:s -
###############################################################################


class ResultItemForPrint(ResultItem):
    """
    An result item that prints a constant string.
    """
    def __init__(self,
                 string: str):
        self._string = string

    def render(self,
               env: RenditionEnvironment) -> str:

        return self._string


class ResultItemForFile(ResultItem):
    """
    An result item that is a file name.
    """
    def __init__(self,
                 file_name: str):
        """
        file_name : the name of the file as specified in the source file -
        i.e. it is relative the source file.
        """
        self.file_name = file_name

    def render(self,
               env: RenditionEnvironment) -> str:
        debug('  ResultItemForFile : ' + self.file_name)
        debug("           env/fromTopLvl : " + env.fromTopLevelFile)
        debug("           env/fromCurrDir: " + env.fromCurrDir)
        return env.render_file_name_according_to_settings(self.file_name)


###############################################################################
# - Instruction:s -
###############################################################################


class InstructionApplicationException(Exception):
    """
    Indicates failure of an instruction to produce one of
    its ResultItem:s.
    """

    def __init__(self,
                 exit_code: int):
        self.exitCode = exit_code

    def render(self, o_stream):
        raise NotImplementedError()


class Instruction(ResultItemsConstructor):
    """
    Base class for instructions.

    An instruction produces an iterable of ResultItem:s.
    """


class File(ResultItemsConstructor):
    """A list of instructions in a single file."""

    def __init__(self,
                 instructions: list):
        self.instructions = instructions

    def result_item_iterable(self,
                             parsing_settings: ParsingSettings,
                             env: Environment):
        return ResultItemIterableForFile(parsing_settings,
                                         self.instructions,
                                         env)


class ResultItemIterableForFile:
    def __init__(self,
                 parsing_settings: ParsingSettings,
                 instructions: list,
                 env: Environment):
        self.instructions = instructions
        self.parsing_settings = parsing_settings
        self.env = env
        self.curr_result_item_iterable = None

    def __iter__(self):
        return self

    def __next__(self):
        while True:
            debug('    iter loop  : instructions.length = ' + str(len(self.instructions)))
            if self.curr_result_item_iterable is None:
                if not self.instructions:
                    debug('   iter stop')
                    raise StopIteration
                self.curr_result_item_iterable = self.instructions[0].result_item_iterable(self.parsing_settings,
                                                                                           self.env)
                del self.instructions[0]
            try:
                debug('       returning')
                return self.curr_result_item_iterable.__next__()
            except StopIteration:
                self.curr_result_item_iterable = None


###############################################################################
# - concrete instructions -
###############################################################################


class InstructionApplicationForMissingFileException(InstructionApplicationException):
    """
    Indicates that a referenced file does not exist.
    """

    def __init__(self,
                 file_name_relative_current_dir_of_process: str):
        InstructionApplicationException.__init__(self,
                                                 EXIT_FILE_DOES_NOT_EXIST)
        self.file_name_relative_current_dir_of_process = file_name_relative_current_dir_of_process

    def render(self, o_stream):
        write_lines(o_stream,
                    [
                        "File does not exist: " +
                        self.file_name_relative_current_dir_of_process
                    ])


###############################################################################
# - InstructionForPrint -
###############################################################################


class InstructionForPrint(Instruction):
    """
    An instruction that resolves a single named file.
    """
    def __init__(self,
                 string: str):
        self._string = string

    def result_item_iterable(self,
                             parsing_settings: ParsingSettings,
                             env: Environment):
        return iter([ResultItemForPrint(self._string)])


###############################################################################
# - InstructionForFile -
###############################################################################


class InstructionForFile(Instruction):
    """
    An instruction that resolves a single named file.
    """
    def __init__(self,
                 file_name: str):
        self.file_name = file_name 

    def result_item_iterable(self,
                             parsing_settings: ParsingSettings,
                             env: Environment):
        file_path = env.file_name_relative_current_dir_of_process(self.file_name)
        if not os.path.exists(file_path):
            raise InstructionApplicationForMissingFileException(file_path)
        result_item = ResultItemForFile(env.file_name_relative_top_level_source_file(self.file_name))
        return iter([result_item])


###############################################################################
# - InstructionForDirectoryListing -
###############################################################################


class ListSettings:
    """
    Settings relevant to directory listing.

    The settings are on a "high level" - ready for use
    without further parsing.
    """
    def __init__(self,
                 relative_directory_name: str,
                 file_matcher,
                 sort: bool):
        self.relative_directory_name = relative_directory_name
        self.file_matcher = file_matcher
        self.sort = sort


class FileMatchInfo:
    """Mutable info about a file to match for inclusion in the result of the program.
    The info is mutable so that matchers can set information they need,
    which may also be needed by later matchers.
    """
    def __init__(self,
                 path: str,
                 base_name: str):
        self._path = path
        self._base_name = base_name
        self._stat_result = None

    def path(self):
        return self._path

    def base_name(self):
        return self._base_name

    def stat_result(self) -> os.stat_result:
        """Return not-None: reads info if not present."""
        if not self._stat_result:
            self._stat_result = os.stat(self.path())
        return self._stat_result


class InstructionForDirectoryListing(Instruction):
    """
    An instruction that resolves the contents of a directory.
    """
    def __init__(self,
                 settings: ListSettings):
        self.settings = settings
        self.env_for_dir = None

    def result_item_iterable(self,
                             parsing_settings: ParsingSettings,
                             env: Environment):
        dir_path = env.file_name_relative_current_dir_of_process(self.settings.relative_directory_name)
        if not os.path.isdir(dir_path):
            raise InstructionApplicationForMissingFileException(dir_path)
        self.env_for_dir = env.new_for_directory(self.settings.relative_directory_name)
        if self.settings.sort:
            return self._sorted_iterable(dir_path)
        else:
            return self._unsorted_iterable(dir_path)

    def _sorted_iterable(self,
                         dir_path: str) -> iter:
        all_files = [self._new_file_match_info(file_name) for file_name in os.listdir(dir_path)]
        matching_base_names = list(map(FileMatchInfo.base_name,
                                   filter(self.settings.file_matcher,
                                          all_files)))
        # sort
        # Sorting here lets us sort on base_name, which is faster than sorting on
        # the complete result file name.
        matching_base_names.sort()
        file_paths = [self._new_file_result(base_name) for base_name in matching_base_names]
        return iter(file_paths)

    def _unsorted_iterable(self,
                           dir_path: str) -> iter:
        for file_base_name in os.listdir(dir_path):
            if not self.settings.file_matcher(self._new_file_match_info(file_base_name)):
                continue
            yield self._new_file_result(file_base_name)

    def _new_file_match_info(self, base_name: str) -> FileMatchInfo:
        return FileMatchInfo(self.env_for_dir.file_name_relative_current_dir_of_process(base_name),
                             base_name)

    def _new_file_result(self, base_name: str) -> ResultItemForFile:
        return ResultItemForFile(
            self.env_for_dir.file_name_relative_top_level_source_file(base_name))


class InstructionForInclude(Instruction):
    """
    An instruction that resolves the contents of a list file.
    """
    def __init__(self,
                 file_name_relative_include_file: str):
        self._file_name_relative_include_file = file_name_relative_include_file

    def result_item_iterable(self,
                             parsing_settings: ParsingSettings,
                             env: Environment):
        file_path = env.file_name_relative_current_dir_of_process(self._file_name_relative_include_file)
        if not os.path.isfile(file_path):
            raise InstructionApplicationForMissingFileException(file_path)
        env_for_file = env.new_for_included_file(self._file_name_relative_include_file)
        debug("incl: " + self._file_name_relative_include_file)
        debug("         env/fromTopLvl : " + env_for_file.fromTopLevelFile)
        debug("         env/fromCurrDir: " + env_for_file.fromCurrDir)
        file_parser = FileParser(parsing_settings,
                                 file_path)
        try:
            file = file_parser.apply(open(file_path,
                                          mode='r'))
        except OSError:
            raise InstructionApplicationForMissingFileException(file_path)
        return file.result_item_iterable(parsing_settings,
                                         env_for_file)


###############################################################################
# - InstructionArgumentParser:s -
###############################################################################


class SourceInfo:
    """Information about a part of a file source."""
    def __init__(self,
                 file_name: str,
                 line_number: int,
                 line_contents: str):
        self.file_name = file_name
        self.line_number = line_number
        self.line_contents = line_contents

    def err_msg_file_ref(self):
        return "File \"" + self.file_name + "\", line " + str(self.line_number)


class InstructionSyntaxErrorException(Exception):
    """A syntactic error in an instruction of a source file."""
    def __init__(self,
                 source_info,
                 description):
        self.source_info = source_info
        self.description = description
    
    def render(self, o_stream):
        source_position = self.source_info.err_msg_file_ref()
        write_lines(o_stream,
                    [
                        source_position,
                        "  " + self.description + ":",
                        "    " + self.source_info.line_contents
                    ])


class InstructionLineSyntaxErrorException(InstructionSyntaxErrorException):
    """Invalid syntax of a line that should contain an instruction."""
    def __init__(self,
                 source_info):
        description = "Invalid input line, cannot find instruction:"
        InstructionSyntaxErrorException.__init__(self,
                                                 source_info,
                                                 description)


class InstructionNameSyntaxErrorException(InstructionSyntaxErrorException):
    """Invalid name of an instruction of a source file."""
    def __init__(self,
                 source_info: SourceInfo,
                 instruction_name: str):
        description = "Invalid instruction name `" + instruction_name + "'"
        InstructionSyntaxErrorException.__init__(self,
                                                 source_info,
                                                 description)


class InstructionArgumentSyntaxErrorException(InstructionSyntaxErrorException):
    """The arguments of an instruction are invalid."""
    def __init__(self,
                 source_info: SourceInfo,
                 lines: list):
        description = "\n".join(lines)
        InstructionSyntaxErrorException.__init__(self,
                                                 source_info,
                                                 description)


class InstructionArgumentParserSyntaxErrorException(Exception):
    """
    A syntactic error in an Instruction Argument of a source file.

    This exception is internal to the File Parser and
    Option Parsers.
    
    This exception is raised by Argument Parsers, and handled by
    the parser, which re-raises it in the form of a
    InstructionSyntaxErrorException.
    """
    def __init__(self,
                 message_lines: list):
        self.message_lines = message_lines

    def message_lines(self):
            return self.message_lines


class InstructionArgumentParser:
    """
    Parses the argument-part of a line in a source file.
    """

    def apply(self,
              parsing_settings: ParsingSettings,
              instruction_argument: str):
        """Returns an Instruction."""
        raise NotImplementedError


class InstructionArgumentParserForFile(InstructionArgumentParser):
    """Parser for a single file."""

    def apply(self,
              parsing_settings: ParsingSettings,
              instruction_argument: str):
        # TODO check syntax of instruction_argument - should be single
        # file name
        return InstructionForFile(instruction_argument)


class InstructionArgumentParserForPrint(InstructionArgumentParser):
    """Parser for printing a string."""

    def apply(self,
              parsing_settings: ParsingSettings,
              instruction_argument: str):
        return InstructionForPrint(instruction_argument)


###############################################################################
# - InstructionArgumentParserForDirectoryListing -
###############################################################################


def wildcard_matcher(wildcard: str):
    """A mather that matches on Unix-style wildcards."""
    debug("           wc: " + str(type(wildcard)) + cq(wildcard))
    try:
        regex_string = fnmatch.translate(wildcard)
        regex = re.compile(regex_string)
    except:
        raise InstructionArgumentParserSyntaxErrorException(["Invalid wildcard: `" + wildcard + "'"])

    def f(file: FileMatchInfo) -> bool:
        return regex.match(file.base_name())
    return f


class FileType:
    """
    Specifies a condition on the type of a file.
    The condition is parsed from a string, making the class
    suitable for us by an ArgumentParser.
    """

    def __init__(self, s: str):
        if s == "f":
            self.mode_predicate = stat.S_ISREG
        elif s == "d":
            self.mode_predicate = stat.S_ISDIR
        else:
            raise InstructionArgumentParserSyntaxErrorException(["Invalid file type `" + s + "'",
                                                                 "Valid types are f,d."])

    def new_matcher(self):
        return file_type_matcher(self)


def file_type_matcher(expected_type: FileType):
    def f(file: FileMatchInfo) -> bool:
        return expected_type.mode_predicate(file.stat_result()[stat.ST_MODE])
    return f


class InstructionArgumentParserForDirectoryListing(InstructionArgumentParser):
    """Parser for the contents of a directory."""

    def apply(self,
              parsing_settings: ParsingSettings,
              instruction_argument: str):
        list_settings = self._parse_arguments(instruction_argument)
        return InstructionForDirectoryListing(list_settings)

    def _parse_arguments(self,
                         instruction_argument: str) -> ListSettings:
        parser = argparse.ArgumentParser(add_help=False,
                                         description="Lists files in a directory")
        parser.add_argument("patterns",
                            metavar="PATTERN",
                            nargs="*",
                            help="Unix-like shell-wildcards for files to print")
        parser.add_argument("-t", "--type",
                            nargs=1,
                            type=FileType,
                            help="""\
                            Condition on the file type.
                            "f" for regular file.
                            "d" for directory.""")
        parser.add_argument('-s', '--sort',
                            action='store_const',
                            const=True,
                            default=False,
                            help='Sort names alphabetically')
        arguments = instruction_argument.split()
        if not arguments:
            raise InstructionArgumentParserSyntaxErrorException(["A directory must be given."])
        directory = arguments[0]
        args = parser.parse_args(arguments[1:])
        debug_cq("Args", args)
        matcher = self._parse_matcher(args.type,
                                      args.patterns)
        return ListSettings(directory,
                            matcher,
                            args.sort)

    @staticmethod
    def _parse_matcher(file_type: list,
                       wildcards: list):
        and_list = []
        if file_type:
            and_list.append(file_type[0].new_matcher())
        if wildcards:
            and_list.append(or_matcher([wildcard_matcher(wildcard) for wildcard in wildcards]))

        return and_matcher(and_list)

    @staticmethod
    def _parse_wildcard_matcher(wildcards: list):
        if not wildcards:
            return constantly_true_matcher()
        return or_matcher([wildcard_matcher(wildcard) for wildcard in wildcards])


class InstructionArgumentParserForInclude(InstructionArgumentParser):
    """Parser for including a file list."""

    def apply(self,
              parsing_settings: ParsingSettings,
              instruction_argument: str):
        # TODO check syntax of instruction_argument - should be single
        # file name
        return InstructionForInclude(instruction_argument)


###############################################################################
# - FileParser -
###############################################################################


class FileParser:
    """
    Parses a source file into a File object.
    """

    @staticmethod
    def for_top_level(parsing_settings: ParsingSettings,
                      file_name: str):
        return FileParser(parsing_settings,
                          file_name)

    ignored_line_re_string = "^\s*(#.*)?$"
    ignored_line_re = re.compile(ignored_line_re_string)

    name_and_argument_groups_re_string = "\s*(\w+)\s*(.*)"
    name_and_argument_groups_re = re.compile(name_and_argument_groups_re_string)

    # Mutable state.
    # Having these here avoids having to pass them around to almost every
    # method.
    # The values are set by the top level method (apply), so that
    # can access them.
    # Only the apply method is allowed to modify this state.
    line_number = -1
    line = ""

    def __init__(self,
                 parsing_settings: ParsingSettings,
                 file_name: str):
        self._parsing_settings = parsing_settings
        self.file_name = file_name

    def apply(self, open_file):
        """
        Returns a File.
        """
        # Read all lines from the file so that we can close it before
        # opening any referenced files.
        # This prevents exhausting the number of open files.
        lines = open_file.readlines()
        open_file.close()

        self.line_number = 0
        instructions = []
        for lineWithPossibleNewLine in lines:
            self.line = lineWithPossibleNewLine.strip('\n')
            self.line_number += 1
            if self._is_ignored_line():
                continue
            instructions.append(self.parse_instruction_line())
        return File(instructions)

    def parse_instruction_line(self):
        (name, argument) = self._split_name_and_argument()
        try:
            parser = self._parsing_settings.parserForInstruction(name.upper())
            return parser.apply(self._parsing_settings, argument)
        except KeyError:
            raise InstructionNameSyntaxErrorException(
                self._source_info(),
                name)
        except InstructionArgumentParserSyntaxErrorException as ex:
            raise InstructionArgumentSyntaxErrorException(self._source_info(),
                                                          ex.message_lines)

    def _split_name_and_argument(self) -> (str, str):
        name_and_argument_match = re.search(self.name_and_argument_groups_re, self.line)
        if not name_and_argument_match:
            raise InstructionLineSyntaxErrorException(self._source_info())
        return (name_and_argument_match.group(1),
                name_and_argument_match.group(2))

    def _is_ignored_line(self):
        return self.ignored_line_re.match(self.line) is not None

    def _source_info(self):
        return SourceInfo(self.file_name,
                          self.line_number,
                          self.line)


###############################################################################
# - configuration of instructions -
###############################################################################


class InstructionDescription:
    """Detailed description of an instruction."""
    def __init__(self,
                 one_line_description: str,
                 arguments_syntax: str,
                 arguments: list,
                 long_description: str):
        """
        :param one_line_description:
        :param arguments_syntax: One-line description of arguments, à la -h
        :param arguments: List of (argument-name,argument-description)
        """
        self.one_line_description = one_line_description
        self.arguments_syntax = arguments_syntax
        self.arguments = arguments
        self.long_description = long_description

    def render_as_lines(self,
                        wrapper: textwrap.TextWrapper) -> list:
        """Renders the description as a list of lines."""
        ret_val = []
        ret_val += self._render_arguments_syntax(wrapper)
        ret_val += self._render_one_line_description(wrapper)
        ret_val += self._render_arguments(wrapper)
        ret_val += self._render_long_description(wrapper)
        return ret_val

    def _render_arguments_syntax(self,
                                 wrapper: textwrap.TextWrapper) -> list:
        syntax = self.arguments_syntax
        if not syntax:
            syntax = "<none>"
        return wrapper.wrap("Arguments: " + syntax)

    def _render_one_line_description(self, wrapper):
        return wrapper.wrap(self.one_line_description)

    def _render_arguments(self, wrapper):
        ret_val = []
        for (identifier,description) in self.arguments:
            ret_val += wrapper.wrap(identifier + " - " + textwrap.dedent(description))
        return ret_val

    def _render_long_description(self, wrapper):
        if self.long_description:
            return wrapper.wrap(textwrap.dedent(self.long_description))
        else:
            return []


class InstructionConfiguration:
    """Complete information about an instruction."""

    def __init__(self,
                 long_name: str,
                 name_aliases: list,
                 description: InstructionDescription,
                 argument_parser: InstructionArgumentParser):
        self.long_name = long_name
        self.name_aliases = name_aliases
        self.description = description
        self.argument_parser = argument_parser

    def render_as_lines(self,
                        wrapper: textwrap.TextWrapper) -> list:
        """Renders the description as a list of lines."""
        saved_initial_indent = wrapper.initial_indent
        ret_val = []
        ret_val += self._render_name_line(wrapper)
        wrapper.initial_indent = wrapper.subsequent_indent
        ret_val += self.description.render_as_lines(wrapper)
        wrapper.initial_indent = saved_initial_indent
        ret_val += ['']
        return ret_val

    def _render_name_line(self, wrapper):
        return wrapper.wrap(self.long_name + " " + str(self.name_aliases))


description_of_print = InstructionDescription(
    "Outputs the argument.",
    "[STRING]",
    [("STRING",
     """\
     String to be printed.
     Extends to the end of line.
     Comment characters are not treated as comments, but is
     included in the printed string.
     """)
     ],
    """\
    If STRING is not given, then an empty line is printed.
    """
)

description_of_file = InstructionDescription(
    "Outputs the path of a file.",
    "FILE",
    [("FILE",
     """\
     A name relative to the location of the list file.
     The file must exist. It can be any type of file (regular, directory ...).
     """)
     ],
    None
)

description_of_directory_list = InstructionDescription(
    "Prints paths of the files inside a directory.",
    "DIRECTORY [-t | --type TYPE] [-s | --sort] [PATTERN...]",
    [("DIRECTORY",
     """\
     A name relative to the location of the list file.
     The directory must exist and be readable.
     """),
    ("TYPE",
     """\
     A condition on the file type that must be satisfied.
     f: regular file; d: directory.
     """),
    ("--sort",
     """\
     Makes the output being sorted in alphabetical order.
     """),
    ("PATTERN",
     """\
     A Unix like shell-style wildcard.
     (E.g. the constructs "*, ?, [abc],[!abc]".)
     Each PATTERN is applied to the base-name of the files in the
     directory.
     If no PATTERN is given, then there is no condition on the
     file name.
     If PATTERNs are given, then the condition on the file name
     is to match at least one of these.
     """)
     ],
    None
)

description_of_include = InstructionDescription(
    "Includes instructions from a file.",
    "FILE",
    [("FIE",
     """\
     A readable file, who's name is relative the including file.
     """)
     ],
    """\
    File paths inside the included file are relative the
    location of that file.
    """
)

blank_line = ""

description_header_of_program_paragraphs = [
    "Prints a list of file paths given a list of file path instructions.",
    "",
    """\
    This is a tool for maintaining a distributed list of files
    that can be accessed via a top level list-file.
    """,
    """\
    The printed paths are all relative the same location - the
    current working directory,
    so that they can be easily accessed by a program.
    """,
    blank_line,
    """\
    The file path instructions can be distributed across several files,
    via an inclusion instruction. The specified file paths in each
    included file is relative the location of the file itself.
    """,
    blank_line,
    """\
    Each line in the input is an instruction that either resolves to one
    or more file paths, or it includes.
    """,
    blank_line,
    """\
    Note: Designed to only work with file names
    that does not contain new-lines.
    """,
    blank_line,
    """\
    Input files consist of white-space lines (ignored),
    comment lines (ignored) and instruction lines.
    Comments begin with a #.
    Instruction lines may not contain comments.
    """,
    blank_line,
    """\
    An instruction line has the form INSTRUCTION-NAME ARGUMENTS.
    """,
    """\
    An INSTRUCTION-NAME is case insensitive, and may have one or more aliases.
    """,
    """\
    The syntax and meaning of ARGUMENTS depend on the instruction, of course.
    """,
    blank_line,
    """\
    instructions:
    """
]

instruction_configurations = [
    InstructionConfiguration("PRINT",
                             ["P"],
                             description_of_print,
                             InstructionArgumentParserForPrint()),
    InstructionConfiguration("FILE",
                             ["F"],
                             description_of_file,
                             InstructionArgumentParserForFile()),
    InstructionConfiguration("LIST",
                             ["L"],
                             description_of_directory_list,
                             InstructionArgumentParserForDirectoryListing()),
    InstructionConfiguration("INCLUDE",
                             ["I"],
                             description_of_include,
                             InstructionArgumentParserForInclude()),
]


def instruction_configurations_lines(wrapper: textwrap.TextWrapper) -> list:
    lines = []
    for i_config in instruction_configurations:
        lines += i_config.render_as_lines(wrapper)
    return lines


def program_description():
    top_level_wrapper = textwrap.TextWrapper(initial_indent="",
                                             subsequent_indent="")

    instruction_wrapper = textwrap.TextWrapper(initial_indent="  ",
                                               subsequent_indent="    ")

    lines = []
    for paragraph in description_header_of_program_paragraphs:
        if paragraph:
            lines += top_level_wrapper.wrap(textwrap.dedent(paragraph))
        else:
            lines.append("\n")
    lines += instruction_configurations_lines(instruction_wrapper)
    return "\n".join(lines)


def instruction_identifier_to_parser_dict() -> dict:
    """
    Gives a dictionary with mappings for all valid instruction identifiers.

    Returns a dict : INSTRUCTION-IDENTIFIER -> InstructionArgumentParser
    """
    ret_val = {}
    for i_conf in instruction_configurations:
        ret_val[i_conf.long_name] = i_conf.argument_parser
        for alias in i_conf.name_aliases:
            ret_val[alias] = i_conf.argument_parser
    return ret_val


###############################################################################
# - main -
###############################################################################


def parse_command_line():
    """
    Returns an (file name,RenditionSettings,open file).
    """
    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
                                     description=program_description())
    parser.add_argument("file",
                        metavar="FILE",
                        help="A file that contains the resolve specification.")
    parser.add_argument("-f", "--relative-file-argument-location",
                        default=False,
                        action='store_true',
                        help="""\
                        File paths are relative the location of the FILE argument.
                        Without this option, file names are relative
                        the location of the invocation of the program.""")
    args = parser.parse_args()
    rendition_settings = RenditionSettings(args.relative_file_argument_location)
    try:
        e = os.path.exists(args.file)
        return (args.file,
                rendition_settings,
                open(args.file,
                     mode='r'))
    except OSError:
        msg = "Cannot open file: \"" + args.file + "\""
        write_lines(sys.stderr,
                    [msg])
        sys.exit(EXIT_INVALID_ARGUMENTS)


def process_file(file_name: str,
                 open_file,
                 rendition_settings: RenditionSettings,
                 parsing_settings: ParsingSettings):
    file_parser = FileParser.for_top_level(parsing_settings,
                                           file_name)
    file = file_parser.apply(open_file)
    env = RenditionEnvironment.for_top_level_file(file_name,
                                                  rendition_settings)
    debug_begin('iter')
    for resultItem in file.result_item_iterable(parsing_settings, env):
        print(resultItem.render(env))
    debug_end('iter')


def main():
    debug_begin('parse')
    (file_name, rendition_settings, open_file) = parse_command_line()
    debug_end('parse')
    try:
        process_file(file_name,
                     open_file,
                     rendition_settings,
                     ParsingSettings(instruction_identifier_to_parser_dict()))
    except InstructionSyntaxErrorException as ex:
        debug('InstructionSyntaxErrorException')
        ex.render(sys.stderr)
        sys.exit(EXIT_SYNTAX)

    except InstructionApplicationException as ex:
        debug('InstructionApplicationException')
        ex.render(sys.stderr)
        sys.exit(ex.exitCode)


main()
