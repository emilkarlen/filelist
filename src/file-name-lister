#! /usr/bin/python3
# -*- coding: utf-8 -*-
# -*- python -*-

###############################################################################
# Copyright 2014 Emil Karl√©n.
# 
# This file is part of file-name-resolver.
# 
# Wilde is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Wilde is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Wilde.  If not, see <http://www.gnu.org/licenses/>.
###############################################################################


###############################################################################
# - parse arguments -
###############################################################################


import sys
import os
import argparse
import re

EXIT_USAGE = 2
EXIT_INVALID_ARGUMENTS = 3
EXIT_SYNTAX = 4
EXIT_FILE_DOES_NOT_EXIST = 8 + 0


###############################################################################
# - utilities -
###############################################################################


debugEnabled = False

def debug(s):
    if debugEnabled:
        sys.stderr.write("DEBUG: " + s)
        sys.stderr.write(os.linesep)

def debug_q(s):
    debug("\"" + s + "\"")

def debug_begin(s):
    debug(s + " BEGIN")

def debug_end(s):
    debug(s + " END")

def write_lines(ostream,lines):
    """Writes a list of lines with an added trailing newline, to a stream."""
    for line in lines:
        ostream.write(line)
        ostream.write(os.linesep)


###############################################################################
# - classes -
###############################################################################


###############################################################################
# - ResultItem:s -
###############################################################################


class Environment:
    """
    Environment for executing instructions.
    """

    def __init__(self,
                 fromCurrDir : str,
                 fromTopLevelFile : str):
        self.fromCurrDir = fromCurrDir
        self.fromTopLevelFile = fromTopLevelFile

    def newForDirectory(self,nameOfDirectory):
        return self._appendDir(nameOfDirectory)

    def newForIncludedFile(self,fileNameRelativeIncludeFile):
        dirDelta = os.path.dirname(fileNameRelativeIncludeFile)
        if not dirDelta: # file is in same directory
            return self
        return self._appendDir(dirDelta)

    def fileNameRelativeCurrentDirOfProc(self,fileName):
        return self.fromCurrDir + fileName

    def fileNameRelativeTopLevelSourceFile(self,fileName):
        return self.fromTopLevelFile + fileName

    def _appendDir(self,dirDelta):
        if dirDelta[-1] != os.path.sep:
            dirDelta += os.path.sep
        return Environment(
            os.path.join(self.fromCurrDir,
                         dirDelta),
            os.path.join(self.fromTopLevelFile,
                         dirDelta))

class RenditionSettings:
    """
    Settings for rendering the output.
    """
    def __init__(self,
                 fileNamesAreRelativeFileArgumentLocation : bool):
        self.fileNamesAreRelativeFileArgumentLocation = fileNamesAreRelativeFileArgumentLocation

class RenditionEnvironment(Environment):
    """
    Environment used during the rendition of a ResultItem.
    """

    @staticmethod
    def forTopLevelFile(fileName,
                        settings : RenditionSettings):
        prefix = os.path.dirname(fileName)
        if prefix:
            prefix = prefix + os.sep
        return RenditionEnvironment(prefix,
                                    '',
                                    settings)

    def __init__(self,
                 fromCurrDir : str,
                 fromTopLevelFile : str,
                 renditionSettings):
        Environment.__init__(self,fromCurrDir,fromTopLevelFile)
        self.renditionSettings = renditionSettings

    def renderFileNameAccordingToSettings(self,fileName):
        if renditionSettings.fileNamesAreRelativeFileArgumentLocation:
            return self.fileNameRelativeTopLevelSourceFile(fileName)
        else:
            return self.fileNameRelativeCurrentDirOfProc(fileName)

class ResultItem:
    """
    An item in a successful result, ready for rendering.

    The rendering is not allowed to raise exceptions related to
    the instruction that constructs this object.  I.e., all checks
    and parses must be done.
    """

    def render(self,env : RenditionEnvironment):
        """
        Renders the item as a string).

        Not allowed to raise exceptions (except for implementation issues,
        of course).
        """
        raise NotImplementedError

class ResultItemsConstructor:
    """An iterable of ResultItem:s."""

    def resultItemIterable(self,env : Environment):
        """
        Gives an iterable of all ResultItem:s that this object represents.

        Can raise exceptions related to parsing and file checking.
        """
        raise NotImplementedError

class ResultItemForFile(ResultItem):
    """
    An result item that is a file name.
    """
    def __init__(self,fileName):
        """
        fileName : the name of the file as specified in the source file -
        i.e. it is relative the source file.
        """
        self.fileName = fileName

    def render(self,env : RenditionEnvironment):
        debug('  ResultItemForFile : ' + self.fileName)
        debug("           env/fromTopLvl : " + env.fromTopLevelFile)
        debug("           env/fromCurrDir: " + env.fromCurrDir)
        return env.renderFileNameAccordingToSettings(self.fileName)


###############################################################################
# - Instruction:s -
###############################################################################


class IntructionApplicationException(Exception):
    """
    Indicates failure of an instruction to produce one of
    its ResultItem:s.
    """

    def __init__(self,exitCode):
        self.exitCode = exitCode

    def render(self,ostream):
        raise NotImplementedError

class Instruction(ResultItemsConstructor):
    """
    Base class for instructions.

    An instruction produces an iterable of ResultItem:s.
    """
    def resultItemIterable(self,env : Environment):
        raise NotImplementedError

class File(ResultItemsConstructor):
    """A list of instructions in a single file."""

    def __init__(self,
                 instructions):
        self.instructions = instructions

    def resultItemIterable(self,env : Environment):
        return ResultItemIterableForFile(self.instructions,env)

class ResultItemIterableForFile:
    def __init__(self,
                 instructions,
                 env : Environment):
        self.instructions = instructions
        self.env = env
        self.currResultItemIterable = None

    def __iter__(self):
        return self

    def __next__(self):
        while True:
            debug('    iter loop  : instructions.length = ' + str(len(self.instructions)))
            if self.currResultItemIterable == None:
                if self.instructions == []:
                    debug('   iter stop')
                    raise StopIteration
                self.currResultItemIterable = self.instructions[0].resultItemIterable(self.env)
                del self.instructions[0]
            try:
                debug('       returning')
                return self.currResultItemIterable.__next__()
            except StopIteration:
                self.currResultItemIterable = None


###############################################################################
# - concrete instructions -
###############################################################################


class IntructionApplicationForMissingFileException(IntructionApplicationException):
    """
    Indicates that a referenced file does not exist.
    """

    def __init__(self,fileNameRelativeCurrentDirOfProc):
        IntructionApplicationException.__init__(self,
                                                EXIT_FILE_DOES_NOT_EXIST)
        self.fileNameRelativeCurrentDirOfProc = fileNameRelativeCurrentDirOfProc

    def render(self,ostream):
        write_lines(ostream,
                    [
                        "File does not exist: " +
                        self.fileNameRelativeCurrentDirOfProc
                    ])

class InstructionForFile(Instruction):
    """
    An instruction that resolves a single named file.
    """
    def __init__(self,fileName):
        self.fileName = fileName 

    def resultItemIterable(self,env : Environment):
        filePath = env.fileNameRelativeCurrentDirOfProc(self.fileName)
        if not os.path.exists(filePath):
            raise IntructionApplicationForMissingFileException(filePath)
        resultItem = ResultItemForFile(env.fileNameRelativeTopLevelSourceFile(self.fileName))
        return iter([resultItem])

class InstructionForDirectoryListing(Instruction):
    """
    An instruction that resolves the contents of a directory.
    """
    def __init__(self,directoryName):
        self.directoryName = directoryName 

    def resultItemIterable(self,env : Environment):
        dirPath = env.fileNameRelativeCurrentDirOfProc(self.directoryName)
        if not os.path.isdir(dirPath):
            raise IntructionApplicationForMissingFileException(dirPath)
        envForDir = env.newForDirectory(self.directoryName)
        debug("list: " + self.directoryName)
        for fileInDir in os.listdir(dirPath):
            fileNameRelCurrDir = envForDir.fileNameRelativeCurrentDirOfProc(fileInDir)
            debug("list   " + fileInDir)
            debug("list   " + fileNameRelCurrDir)
            if os.path.exists(fileNameRelCurrDir):
                yield ResultItemForFile(
                    envForDir.fileNameRelativeTopLevelSourceFile(fileInDir))

class InstructionForForInclude(Instruction):
    """
    An instruction that resolves the contents of a list file.
    """
    def __init__(self,fileNameRelativeIncludeFile):
        self.fileNameRelativeIncludeFile = fileNameRelativeIncludeFile

    def resultItemIterable(self,env : Environment):
        filePath = env.fileNameRelativeCurrentDirOfProc(self.fileNameRelativeIncludeFile)
        if not os.path.isfile(filePath):
            raise IntructionApplicationForMissingFileException(filePath)
        envForFile = env.newForIncludedFile(self.fileNameRelativeIncludeFile)
        debug("incl: " + self.fileNameRelativeIncludeFile)
        debug("         env/fromTopLvl : " + envForFile.fromTopLevelFile)
        debug("         env/fromCurrDir: " + envForFile.fromCurrDir)
        fileParser = FileParser(filePath)
        try:
            file = fileParser.apply(open(filePath,mode='r'))
        except OSError:
            raise IntructionApplicationForMissingFileException(filePath)
        return file.resultItemIterable(envForFile)


###############################################################################
# - InstructionOptionParser:s -
###############################################################################


class SourceInfo:
    """Information about a part of a file source."""
    def __init__(self,
                 fileName,
                 lineNumber,
                 lineContents):
        self.fileName = fileName
        self.lineNumber = lineNumber
        self.lineContents = lineContents

    def errMsgFileRef(self):
        return "File \"" + self.fileName + "\", line " + str(self.lineNumber)

class InstructionSyntaxErrorException(Exception):
    """A syntactic error in an instruction of a source file."""
    def __init__(self,sourceInfo,description):
        self.sourceInfo = sourceInfo
        self.description = description
    
    def render(self,ostream):
        sourcePosition = self.sourceInfo.errMsgFileRef()
        write_lines(ostream,
                    [
                        sourcePosition,
                        "  " + self.description + ":",
                        "    " + self.sourceInfo.lineContents
                    ])

class InstructionLineSyntaxErrorException(InstructionSyntaxErrorException):
    """Invalid syntax of a line that should contain an instruction."""
    def __init__(self,
                 sourceInfo):
        description = "Invalid input line, cannot find instruction:"
        InstructionSyntaxErrorException.__init__(self,
                                                 sourceInfo,
                                                 description)

class InstructionNameSyntaxErrorException(InstructionSyntaxErrorException):
    """Invalid name of an instruction of a source file."""
    def __init__(self,
                 sourceInfo,
                 instructionName):
        description = "Invalid instruction name `" + instructionName + "'"
        InstructionSyntaxErrorException.__init__(self,
                                                 sourceInfo,
                                                 description)

class InstructionOptionSyntaxErrorException(Exception):
    """
    A syntactic error in an Instruction Option of a source file.

    This exception is internal to the File Parser and
    Option Parsers.
    
    This exception is raised by Option Parsers, and handled by
    the parser, which re-rases it in the form of a
    InstructionSyntaxErrorException.
    """
    def __init__(self,messageLines):
        self._messageLines = messageLines

    def messageLines(self):
            return self._messageLines

class InstructionOptionParser:
    """
    Parses the options-part of a line in a source file.
    """

    def apply(self,instructionOptions):
        """Returns an Instruction."""
        raise NotImplementedError

class InstructionOptionParserForFile(InstructionOptionParser):
    """Parser for a single file."""

    def apply(self,instructionOptions):
        # TODO check syntax of instructionOptions - should be single
        # file name
        return InstructionForFile(instructionOptions)

class InstructionOptionParserForDirectoryListing(InstructionOptionParser):
    """Parser for the contents of a directory."""

    def apply(self,instructionOptions):
        # TODO check syntax of instructionOptions - should be single
        # file name
        return InstructionForDirectoryListing(instructionOptions)

class InstructionOptionParserForInclude(InstructionOptionParser):
    """Parser for including a file list."""

    def apply(self,instructionOptions):
        # TODO check syntax of instructionOptions - should be single
        # file name
        return InstructionForForInclude(instructionOptions)


###############################################################################
# - FileParser -
###############################################################################


class FileParser:
    """
    Parses a source file into a File object.
    """

    @staticmethod
    def forTopLevel(fileName):
        return FileParser(fileName)

    parsers = {
        "FILE"    : InstructionOptionParserForFile(),
        "LIST"    : InstructionOptionParserForDirectoryListing(),
        "INCLUDE" : InstructionOptionParserForInclude()
    }

    ignoredLineReString = "^\s*(#.*)?$"
    ignoredLineRe = re.compile(ignoredLineReString)

    nameAndOptionGroupsReString = "\s*(\w+)\s*(.*)"
    nameAndOptionGroupsRe = re.compile(nameAndOptionGroupsReString)

    # Mutable state.
    # Having these here avoids having to pass them around to almost every
    # method.
    # The values are set by the top level method (apply), so that
    # can access them.
    # Only the apply method is allowed to modify this state.
    lineNumber = -1
    line = ""

    def __init__(self,fileName):
        self.fileName = fileName

    def apply(self,openFile):
        """
        Returns a File.
        """
        # Read all lines from the file so that we can close it before
        # opening any referenced files.
        # This prevents exhausting the number of open files.
        lines = openFile.readlines()
        openFile.close()

        self.lineNumber = 0
        instructions = []
        for lineWithPossibleNewLine in lines:
            self.line = lineWithPossibleNewLine.strip('\n')
            self.lineNumber += 1
            if (self._is_ignored_line()):
                continue
            instructions.append(self.parse_instruction_line())
        return File(instructions)

    def parse_instruction_line(self):
        (name,option) = self._split_name_and_option()
        try:
            parser = self.parsers[name]
            return parser.apply(option)
        except KeyError:
            raise InstructionNameSyntaxErrorException(
                self._sourceInfo(),
                name)

    def _split_name_and_option(self):
        nameAndOptionMatch = re.search(self.nameAndOptionGroupsRe,self.line)
        if (not nameAndOptionMatch):
            raise InstructionLineSyntaxErrorException(self._sourceInfo())
        return (nameAndOptionMatch.group(1),
                nameAndOptionMatch.group(2))

    def _is_ignored_line(self):
        return (self.ignoredLineRe.match(self.line) != None)

    def _sourceInfo(self):
        return SourceInfo(self.fileName,
                          self.lineNumber,
                          self.line)


###############################################################################
# - parse_command_line -
###############################################################################


def parse_command_line():
    """
    Returns an (file name,RenditionSettings,open file).
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("file",
                        metavar="FILE",
                        help="A file that contains the resolve specification.")
    parser.add_argument("--relative-file-argument-location","-f",
                        default=False,
                        action='store_true',
                        help="File paths are relative the location of the FILE argument. Without this option, file names are relative the location of the invocation of the program.")
    args = parser.parse_args()
    renditionSettings = RenditionSettings(args.relative_file_argument_location)
    try:
        e = os.path.exists(args.file)
        return (args.file,
                renditionSettings,
                open(args.file,mode='r'))
    except OSError:
        msg = "Cannot open file: \"" + args.file + "\""
        write_lines(sys.stderr,
                    [msg])
        sys.exit(EXIT_INVALID_ARGUMENTS)



###############################################################################
# - main -
###############################################################################


debug_begin('parse')
(fileName,renditionSettings,openFile) = parse_command_line()
debug_end('parse')
try:
    file = FileParser.forTopLevel(fileName).apply(openFile)
    env = RenditionEnvironment.forTopLevelFile(fileName,renditionSettings)
    debug_begin('iter')
    for resultItem in file.resultItemIterable(env):
        print(resultItem.render(env))
    debug_end('iter')

except InstructionSyntaxErrorException as ex:
    debug('InstructionSyntaxErrorException')
    ex.render(sys.stderr)
    sys.exit(EXIT_SYNTAX)

except IntructionApplicationException as ex:
    debug('IntructionApplicationException')
    ex.render(sys.stderr)
    sys.exit(ex.exitCode)
