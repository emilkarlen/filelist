#! /usr/bin/python3
# -*- python -*-
# -*- coding: utf-8 -*-

###############################################################################
# Copyright 2014 Emil Karl√©n.
# 
# This file is part of file-name-resolver.
# 
# Wilde is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Wilde is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Wilde.  If not, see <http://www.gnu.org/licenses/>.
###############################################################################


###############################################################################
# - parse arguments -
###############################################################################


import sys
import os
import argparse
import re
import textwrap

EXIT_USAGE = 2
EXIT_INVALID_ARGUMENTS = 3
EXIT_SYNTAX = 4
EXIT_FILE_DOES_NOT_EXIST = 8 + 0


###############################################################################
# - utilities -
###############################################################################


debugEnabled = False


def debug(s):
    if debugEnabled:
        sys.stderr.write("DEBUG: " + s)
        sys.stderr.write(os.linesep)


def debug_q(s):
    debug("\"" + s + "\"")


def debug_begin(s):
    debug(s + " BEGIN")


def debug_end(s):
    debug(s + " END")


def write_lines(o_stream,lines):
    """Writes a list of lines with an added trailing newline, to a stream."""
    for line in lines:
        o_stream.write(line)
        o_stream.write(os.linesep)


###############################################################################
# - classes -
###############################################################################


class Environment:
    """
    Environment for executing instructions.
    """

    def __init__(self,
                 from_curr_dir: str,
                 from_top_level_file: str):
        self.fromCurrDir = from_curr_dir
        self.fromTopLevelFile = from_top_level_file

    def new_for_directory(self, name_of_directory):
        return self._append_dir(name_of_directory)

    def new_for_included_file(self, file_name_relative_include_file):
        dir_delta = os.path.dirname(file_name_relative_include_file)
        if not dir_delta:  # file is in same directory
            return self
        return self._append_dir(dir_delta)

    def file_name_relative_current_dir_of_process(self, file_name):
        return self.fromCurrDir + file_name

    def file_name_relative_top_level_source_file(self, file_name):
        return self.fromTopLevelFile + file_name

    def _append_dir(self, dir_delta):
        if dir_delta[-1] != os.path.sep:
            dir_delta += os.path.sep
        return Environment(
            os.path.join(self.fromCurrDir,
                         dir_delta),
            os.path.join(self.fromTopLevelFile,
                         dir_delta))


###############################################################################
# - ResultItem:s -
###############################################################################


class RenditionSettings:
    """
    Settings for rendering the output.
    """
    def __init__(self,
                 file_names_are_relative_file_argument_location: bool):
        """
        :rtype : RenditionSettings
        """
        self.file_names_are_relative_file_argument_location = file_names_are_relative_file_argument_location


class RenditionEnvironment(Environment):
    """
    Environment used during the rendition of a ResultItem.
    """

    @staticmethod
    def for_top_level_file(file_name: str,
                           settings: RenditionSettings):
        prefix = os.path.dirname(file_name)
        if prefix:
            prefix = prefix + os.sep
        return RenditionEnvironment(prefix,
                                    '',
                                    settings)

    def __init__(self,
                 from_curr_dir: str,
                 from_top_level_file: str,
                 rendition_settings: RenditionSettings):
        Environment.__init__(self,
                             from_curr_dir,
                             from_top_level_file)
        self.rendition_settings = rendition_settings

    def render_file_name_according_to_settings(self, file_name):
        if rendition_settings.file_names_are_relative_file_argument_location:
            return self.file_name_relative_top_level_source_file(file_name)
        else:
            return self.file_name_relative_current_dir_of_process(file_name)


class ResultItem:
    """
    An item in a successful result, ready for rendering.

    The rendering is not allowed to raise exceptions related to
    the instruction that constructs this object.  I.e., all checks
    and parses must be done.
    """

    def render(self,
               env: RenditionEnvironment):
        """
        Renders the item as a string).

        Not allowed to raise exceptions (except for implementation issues,
        of course).
        """
        raise NotImplementedError()


class ParsingSettings:
    def __init__(self,
                 instruction_parsers_dict: dict):
        """
        :param instruction_parsers_dict: Maps instruction identifiers to
         parsers: str -> InstructionArgumentParser.
        """
        self.instruction_parsers_dict = instruction_parsers_dict

    def parserForInstruction(self,
                             identifier: str):
        return self.instruction_parsers_dict[identifier]


class ResultItemsConstructor:
    """An iterable of ResultItem:s."""

    def result_item_iterable(self,
                             parsing_settings: ParsingSettings,
                             env: Environment):
        """
        Gives an iterable of all ResultItem:s that this object represents.

        Can raise exceptions related to parsing and file checking.
        """
        raise NotImplementedError()


###############################################################################
# - concrete ResultItem:s -
###############################################################################


class ResultItemForFile(ResultItem):
    """
    An result item that is a file name.
    """
    def __init__(self,
                 file_name: str):
        """
        file_name : the name of the file as specified in the source file -
        i.e. it is relative the source file.
        """
        self.file_name = file_name

    def render(self,
               env: RenditionEnvironment):
        debug('  ResultItemForFile : ' + self.file_name)
        debug("           env/fromTopLvl : " + env.fromTopLevelFile)
        debug("           env/fromCurrDir: " + env.fromCurrDir)
        return env.render_file_name_according_to_settings(self.file_name)


###############################################################################
# - Instruction:s -
###############################################################################


class InstructionApplicationException(Exception):
    """
    Indicates failure of an instruction to produce one of
    its ResultItem:s.
    """

    def __init__(self,
                 exit_code: int):
        self.exitCode = exit_code

    def render(self, o_stream):
        raise NotImplementedError()


class Instruction(ResultItemsConstructor):
    """
    Base class for instructions.

    An instruction produces an iterable of ResultItem:s.
    """

class File(ResultItemsConstructor):
    """A list of instructions in a single file."""

    def __init__(self,
                 instructions: list):
        self.instructions = instructions

    def result_item_iterable(self,
                             parsing_settings: ParsingSettings,
                             env: Environment):
        return ResultItemIterableForFile(parsing_settings,
                                         self.instructions,
                                         env)


class ResultItemIterableForFile:
    def __init__(self,
                 parsing_settings: ParsingSettings,
                 instructions: list,
                 env: Environment):
        self.instructions = instructions
        self.parsing_settings = parsing_settings
        self.env = env
        self.curr_result_item_iterable = None

    def __iter__(self):
        return self

    def __next__(self):
        while True:
            debug('    iter loop  : instructions.length = ' + str(len(self.instructions)))
            if self.curr_result_item_iterable is None:
                if not self.instructions:
                    debug('   iter stop')
                    raise StopIteration
                self.curr_result_item_iterable = self.instructions[0].result_item_iterable(self.parsing_settings,
                                                                                           self.env)
                del self.instructions[0]
            try:
                debug('       returning')
                return self.curr_result_item_iterable.__next__()
            except StopIteration:
                self.curr_result_item_iterable = None


###############################################################################
# - concrete instructions -
###############################################################################


class InstructionApplicationForMissingFileException(InstructionApplicationException):
    """
    Indicates that a referenced file does not exist.
    """

    def __init__(self,
                 file_name_relative_current_dir_of_process: str):
        InstructionApplicationException.__init__(self,
                                                 EXIT_FILE_DOES_NOT_EXIST)
        self.file_name_relative_current_dir_of_process = file_name_relative_current_dir_of_process

    def render(self, o_stream):
        write_lines(o_stream,
                    [
                        "File does not exist: " +
                        self.file_name_relative_current_dir_of_process
                    ])


class InstructionForFile(Instruction):
    """
    An instruction that resolves a single named file.
    """
    def __init__(self,
                 file_name: str):
        self.file_name = file_name 

    def result_item_iterable(self,
                             parsing_settings: ParsingSettings,
                             env: Environment):
        file_path = env.file_name_relative_current_dir_of_process(self.file_name)
        if not os.path.exists(file_path):
            raise InstructionApplicationForMissingFileException(file_path)
        result_item = ResultItemForFile(env.file_name_relative_top_level_source_file(self.file_name))
        return iter([result_item])


class InstructionForDirectoryListing(Instruction):
    """
    An instruction that resolves the contents of a directory.
    """
    def __init__(self, directory_name: str):
        self.directory_name = directory_name 

    def result_item_iterable(self,
                             parsing_settings: ParsingSettings,
                             env: Environment):
        dir_path = env.file_name_relative_current_dir_of_process(self.directory_name)
        if not os.path.isdir(dir_path):
            raise InstructionApplicationForMissingFileException(dir_path)
        env_for_dir = env.new_for_directory(self.directory_name)
        debug("list: " + self.directory_name)
        for fileInDir in os.listdir(dir_path):
            file_name_rel_curr_dir = env_for_dir.file_name_relative_current_dir_of_process(fileInDir)
            debug("list   " + fileInDir)
            debug("list   " + file_name_rel_curr_dir)
            if os.path.exists(file_name_rel_curr_dir):
                yield ResultItemForFile(
                    env_for_dir.file_name_relative_top_level_source_file(fileInDir))


class InstructionForInclude(Instruction):
    """
    An instruction that resolves the contents of a list file.
    """
    def __init__(self,
                 file_name_relative_include_file: str):
        self._file_name_relative_include_file= file_name_relative_include_file

    def result_item_iterable(self,
                             parsing_settings: ParsingSettings,
                             env: Environment):
        file_path = env.file_name_relative_current_dir_of_process(self._file_name_relative_include_file)
        if not os.path.isfile(file_path):
            raise InstructionApplicationForMissingFileException(file_path)
        env_for_file = env.new_for_included_file(self._file_name_relative_include_file)
        debug("incl: " + self._file_name_relative_include_file)
        debug("         env/fromTopLvl : " + env_for_file.fromTopLevelFile)
        debug("         env/fromCurrDir: " + env_for_file.fromCurrDir)
        file_parser = FileParser(parsing_settings,
                                 file_path)
        try:
            file = file_parser.apply(open(file_path,
                                          mode='r'))
        except OSError:
            raise InstructionApplicationForMissingFileException(file_path)
        return file.result_item_iterable(parsing_settings,
                                         env_for_file)


###############################################################################
# - InstructionArgumentParser:s -
###############################################################################


class SourceInfo:
    """Information about a part of a file source."""
    def __init__(self,
                 file_name: str,
                 line_number: int,
                 line_contents: str):
        self.file_name = file_name
        self.line_number = line_number
        self.line_contents = line_contents

    def err_msg_file_ref(self):
        return "File \"" + self.file_name + "\", line " + str(self.line_number)


class InstructionSyntaxErrorException(Exception):
    """A syntactic error in an instruction of a source file."""
    def __init__(self,
                 source_info,
                 description):
        self.source_info = source_info
        self.description = description
    
    def render(self, o_stream):
        source_position = self.source_info.err_msg_file_ref()
        write_lines(o_stream,
                    [
                        source_position,
                        "  " + self.description + ":",
                        "    " + self.source_info.line_contents
                    ])


class InstructionLineSyntaxErrorException(InstructionSyntaxErrorException):
    """Invalid syntax of a line that should contain an instruction."""
    def __init__(self,
                 source_info):
        description = "Invalid input line, cannot find instruction:"
        InstructionSyntaxErrorException.__init__(self,
                                                 source_info,
                                                 description)


class InstructionNameSyntaxErrorException(InstructionSyntaxErrorException):
    """Invalid name of an instruction of a source file."""
    def __init__(self,
                 source_info: SourceInfo,
                 instruction_name: str):
        description = "Invalid instruction name `" + instruction_name + "'"
        InstructionSyntaxErrorException.__init__(self,
                                                 source_info,
                                                 description)


class InstructionArgumentSyntaxErrorException(Exception):
    """
    A syntactic error in an Instruction Option of a source file.

    This exception is internal to the File Parser and
    Option Parsers.
    
    This exception is raised by Option Parsers, and handled by
    the parser, which re-raises it in the form of a
    InstructionSyntaxErrorException.
    """
    def __init__(self,
                 message_lines: list):
        self._message_lines = message_lines

    def message_lines(self):
            return self._message_lines


class InstructionArgumentParser:
    """
    Parses the argument-part of a line in a source file.
    """

    def apply(self,
              parsing_settings: ParsingSettings,
              instruction_argument: str):
        """Returns an Instruction."""
        raise NotImplementedError


class InstructionArgumentParserForFile(InstructionArgumentParser):
    """Parser for a single file."""

    def apply(self,
              parsing_settings: ParsingSettings,
              instruction_argument: str):
        # TODO check syntax of instruction_argument - should be single
        # file name
        return InstructionForFile(instruction_argument)


class InstructionArgumentParserForDirectoryListing(InstructionArgumentParser):
    """Parser for the contents of a directory."""

    def apply(self,
              parsing_settings: ParsingSettings,
              instruction_argument: str):
        # TODO check syntax of instruction_argument - should be single
        # file name
        return InstructionForDirectoryListing(instruction_argument)


class InstructionArgumentParserForInclude(InstructionArgumentParser):
    """Parser for including a file list."""

    def apply(self,
              parsing_settings: ParsingSettings,
              instruction_argument: str):
        # TODO check syntax of instruction_argument - should be single
        # file name
        return InstructionForInclude(instruction_argument)


###############################################################################
# - FileParser -
###############################################################################


class FileParser:
    """
    Parses a source file into a File object.
    """

    @staticmethod
    def for_top_level(parsing_settings: ParsingSettings,
                      file_name: str):
        return FileParser(parsing_settings,
                          file_name)

    ignored_line_re_string = "^\s*(#.*)?$"
    ignored_line_re = re.compile(ignored_line_re_string)

    name_and_argument_groups_re_string = "\s*(\w+)\s*(.*)"
    name_and_argument_groups_re = re.compile(name_and_argument_groups_re_string)

    # Mutable state.
    # Having these here avoids having to pass them around to almost every
    # method.
    # The values are set by the top level method (apply), so that
    # can access them.
    # Only the apply method is allowed to modify this state.
    line_number = -1
    line = ""

    def __init__(self,
                 parsing_settings: ParsingSettings,
                 file_name: str):
        self._parsing_settings = parsing_settings
        self.file_name = file_name

    def apply(self, open_file):
        """
        Returns a File.
        """
        # Read all lines from the file so that we can close it before
        # opening any referenced files.
        # This prevents exhausting the number of open files.
        lines = open_file.readlines()
        open_file.close()

        self.line_number = 0
        instructions = []
        for lineWithPossibleNewLine in lines:
            self.line = lineWithPossibleNewLine.strip('\n')
            self.line_number += 1
            if self._is_ignored_line():
                continue
            instructions.append(self.parse_instruction_line())
        return File(instructions)

    def parse_instruction_line(self):
        (name, argument) = self._split_name_and_argument()
        try:
            parser = self._parsing_settings.parserForInstruction(name)
            return parser.apply(self._parsing_settings,argument)
        except KeyError:
            raise InstructionNameSyntaxErrorException(
                self._source_info(),
                name)

    def _split_name_and_argument(self):
        name_and_argument_match = re.search(self.name_and_argument_groups_re, self.line)
        if not name_and_argument_match:
            raise InstructionLineSyntaxErrorException(self._source_info())
        return (name_and_argument_match.group(1),
                name_and_argument_match.group(2))

    def _is_ignored_line(self):
        return self.ignored_line_re.match(self.line) is not None

    def _source_info(self):
        return SourceInfo(self.file_name,
                          self.line_number,
                          self.line)


###############################################################################
# - configuration of instructions -
###############################################################################


class InstructionDescription:
    """Detailed description of an instruction."""
    def __init__(self,
                 one_line_description: str,
                 arguments_syntax: str,
                 arguments: list,
                 long_description: str):
        """
        :param one_line_description:
        :param arguments_syntax: One-line description of arguments, √† la -h
        :param arguments: List of (argument-name,argument-description)
        """
        self.one_line_description = one_line_description
        self.arguments_syntax = arguments_syntax
        self.arguments = arguments
        self.long_description = long_description

    def render_as_lines(self,
                        wrapper: textwrap.TextWrapper) -> list:
        """Renders the description as a list of lines."""
        ret_val = []
        ret_val += self._render_arguments_syntax(wrapper)
        ret_val += self._render_one_line_description(wrapper)
        ret_val += self._render_arguments(wrapper)
        ret_val += self._render_long_description(wrapper)
        return ret_val

    def _render_arguments_syntax(self,
                                 wrapper: textwrap.TextWrapper) -> list:
        syntax = self.arguments_syntax
        if not syntax:
            syntax = "<none>"
        return wrapper.wrap("Arguments: " + syntax)

    def _render_one_line_description(self, wrapper):
        return wrapper.wrap(self.one_line_description)

    def _render_arguments(self, wrapper):
        ret_val = []
        for (identifier,description) in self.arguments:
            ret_val += wrapper.wrap(identifier + " - " + textwrap.dedent(description))
        return ret_val

    def _render_long_description(self, wrapper):
        if self.long_description:
            return wrapper.wrap(textwrap.dedent(self.long_description))
        else:
            return []


class InstructionConfiguration:
    """Complete information about an instruction."""

    def __init__(self,
                 long_name: str,
                 name_aliases: list,
                 description: InstructionDescription,
                 argument_parser: InstructionArgumentParser):
        self.long_name = long_name
        self.name_aliases = name_aliases
        self.description = description
        self.argument_parser = argument_parser

    def render_as_lines(self,
                        wrapper: textwrap.TextWrapper) -> list:
        """Renders the description as a list of lines."""
        saved_initial_indent = wrapper.initial_indent
        ret_val = []
        ret_val += self._render_name_line(wrapper)
        wrapper.initial_indent = wrapper.subsequent_indent
        ret_val += self.description.render_as_lines(wrapper)
        wrapper.initial_indent = saved_initial_indent
        ret_val += ['']
        return ret_val

    def _render_name_line(self, wrapper):
        return wrapper.wrap(self.long_name + " " + str(self.name_aliases))


description_of_file = InstructionDescription(
    "Outputs the path of a file.",
    "FILE",
    [("FILE",
     """\
     A name relative to the location of the list file.
     The file must exist. It can be any type of file (regular, directory ...).
     """)
    ],
     None
)

description_of_directory = InstructionDescription(
    "Outputs the pats of the files inside a directory.",
    "DIRECTORY",
    [("DIRECTORY",
     """\
     A name relative to the location of the list file.
     The directory must exist and be readable.
     """)
    ],
    None
)

description_of_include = InstructionDescription(
    "Includes instructions from a file.",
    "FILE",
    [("FIE",
     """\
     A readable file, who's name is relative the including file.
     """)
     ],
     """\
     File paths inside the included file are relative the
     location of that file.
     """
)

blank_line = ""

description_header_of_program_paragraphs = [
    "Prints a list of file paths given a list of file path instructions.",
    "",
    """\
    This is a tool for maintaining a distributed list of files
    that can be accessed via a top level list-file.
    """,
    """\
    The printed paths are all relative the same location - the
    current working directory,
    so that they can be easily accessed by a program.
    """,
    blank_line,
    """\
    The file path instructions can be distributed across several files,
    via an inclusion instruction. The specified file paths in each
    included file is relative the location of the file itself.
    """,
    blank_line,
    """\
    Each line in the input is an instruction that either resolves to one
    or more file paths, or it includes.
    """,
    blank_line,
    """\
    Note: Designed to only work with file names
    that does not contain new-lines.
    """,
    blank_line,
    """\
    Input files consist of white-space lines (ignored),
    comment lines (ignored) and instruction lines.
    Comments begin with a #.
    Instruction lines may not contain comments.
    """,
    blank_line,
    """\
    An instruction line has the form INSTRUCTION-NAME ARGUMENTS.
    """,
    """\
    An INSTRUCTION-NAME is case insensitive, and may have one or more aliases.
    """,
    """\
    The syntax and meaning of ARGUMENTS depend on the instruction, of course.
    """,
    blank_line,
    """\
    List of instructions:
    """
]

instruction_configurations = [
    InstructionConfiguration("FILE",
                             ["F"],
                             description_of_file,
                             InstructionArgumentParserForFile()),
    InstructionConfiguration("LIST",
                             ["L"],
                             description_of_directory,
                             InstructionArgumentParserForDirectoryListing()),
    InstructionConfiguration("INCLUDE",
                             ["I"],
                             description_of_include,
                             InstructionArgumentParserForInclude()),
]

def instruction_configurations_lines(wrapper: textwrap.TextWrapper) -> list:
    lines = []
    for i_config in instruction_configurations:
        lines += i_config.render_as_lines(wrapper)
    return lines

def program_description():
    top_level_wrapper = textwrap.TextWrapper(initial_indent="",
                                             subsequent_indent="")

    instruction_wrapper = textwrap.TextWrapper(initial_indent="  ",
                                             subsequent_indent="    ")

    lines = []
    for paragraph in description_header_of_program_paragraphs:
        if paragraph:
            lines += top_level_wrapper.wrap(textwrap.dedent(paragraph))
        else:
            lines.append("\n")
    lines += instruction_configurations_lines(instruction_wrapper)
    return "\n".join(lines)

def instruction_identifier_to_parser_dict() -> dict:
    """
    Gives a dictionary with mappings for all valid instruction identifiers.

    Returns a dict : INSTRUCTION-IDENTIFIER -> InstructionArgumentParser
    """
    ret_val = {}
    for i_conf in instruction_configurations:
        ret_val[i_conf.long_name] = i_conf.argument_parser
        for alias in i_conf.name_aliases:
           ret_val[alias] = i_conf.argument_parser
    return ret_val


###############################################################################
# - parse_command_line -
###############################################################################


def parse_command_line():
    """
    Returns an (file name,RenditionSettings,open file).
    """
    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
                                     description=program_description())
    parser.add_argument("file",
                        metavar="FILE",
                        help="A file that contains the resolve specification.")
    parser.add_argument( "-f", "--relative-file-argument-location",
                        default=False,
                        action='store_true',
                        help="""\
                        File paths are relative the location of the FILE argument.
                        Without this option, file names are relative
                        the location of the invocation of the program.""")
    args = parser.parse_args()
    rendition_settings = RenditionSettings(args.relative_file_argument_location)
    try:
        e = os.path.exists(args.file)
        return (args.file,
                rendition_settings,
                open(args.file,
                     mode='r'))
    except OSError:
        msg = "Cannot open file: \"" + args.file + "\""
        write_lines(sys.stderr,
                    [msg])
        sys.exit(EXIT_INVALID_ARGUMENTS)



###############################################################################
# - main -
###############################################################################


debug_begin('parse')
(file_name, rendition_settings, open_file) = parse_command_line()
debug_end('parse')
try:
    parsing_settings = ParsingSettings(instruction_identifier_to_parser_dict())
    file_parser = FileParser.for_top_level(parsing_settings,
                                           file_name)
    file = file_parser.apply(open_file)
    env = RenditionEnvironment.for_top_level_file(file_name,
                                                  rendition_settings)
    debug_begin('iter')
    for resultItem in file.result_item_iterable(parsing_settings,env):
        print(resultItem.render(env))
    debug_end('iter')

except InstructionSyntaxErrorException as ex:
    debug('InstructionSyntaxErrorException')
    ex.render(sys.stderr)
    sys.exit(EXIT_SYNTAX)

except InstructionApplicationException as ex:
    debug('InstructionApplicationException')
    ex.render(sys.stderr)
    sys.exit(ex.exitCode)
