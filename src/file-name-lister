#! /usr/bin/python3
# -*- python -*-
# -*- coding: utf-8 -*-

###############################################################################
# Copyright 2014 Emil Karl√©n.
# 
# This file is part of file-name-resolver.
# 
# Wilde is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Wilde is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Wilde.  If not, see <http://www.gnu.org/licenses/>.
###############################################################################


###############################################################################
# - parse arguments -
###############################################################################


import sys
import os
import argparse
import re

EXIT_USAGE = 2
EXIT_INVALID_ARGUMENTS = 3
EXIT_SYNTAX = 4
EXIT_FILE_DOES_NOT_EXIST = 8 + 0


###############################################################################
# - utilities -
###############################################################################


debugEnabled = False


def debug(s):
    if debugEnabled:
        sys.stderr.write("DEBUG: " + s)
        sys.stderr.write(os.linesep)


def debug_q(s):
    debug("\"" + s + "\"")


def debug_begin(s):
    debug(s + " BEGIN")


def debug_end(s):
    debug(s + " END")


def write_lines(o_stream,lines):
    """Writes a list of lines with an added trailing newline, to a stream."""
    for line in lines:
        o_stream.write(line)
        o_stream.write(os.linesep)


###############################################################################
# - classes -
###############################################################################


###############################################################################
# - ResultItem:s -
###############################################################################


class Environment:
    """
    Environment for executing instructions.
    """

    def __init__(self,
                 from_curr_dir: str,
                 from_top_level_file: str):
        self.fromCurrDir = from_curr_dir
        self.fromTopLevelFile = from_top_level_file

    def new_for_directory(self, name_of_directory):
        return self._append_dir(name_of_directory)

    def new_for_included_file(self, file_name_relative_include_file):
        dir_delta = os.path.dirname(file_name_relative_include_file)
        if not dir_delta:  # file is in same directory
            return self
        return self._append_dir(dir_delta)

    def file_name_relative_current_dir_of_process(self, file_name):
        return self.fromCurrDir + file_name

    def file_name_relative_top_level_source_file(self, file_name):
        return self.fromTopLevelFile + file_name

    def _append_dir(self, dir_delta):
        if dir_delta[-1] != os.path.sep:
            dir_delta += os.path.sep
        return Environment(
            os.path.join(self.fromCurrDir,
                         dir_delta),
            os.path.join(self.fromTopLevelFile,
                         dir_delta))


class RenditionSettings:
    """
    Settings for rendering the output.
    """
    def __init__(self,
                 file_names_are_relative_file_argument_location: bool):
        """

        :rtype : RenditionSettings
        """
        self.file_names_are_relative_file_argument_location = file_names_are_relative_file_argument_location


class RenditionEnvironment(Environment):
    """
    Environment used during the rendition of a ResultItem.
    """

    @staticmethod
    def for_top_level_file(file_name: str,
                           settings: RenditionSettings):
        prefix = os.path.dirname(file_name)
        if prefix:
            prefix = prefix + os.sep
        return RenditionEnvironment(prefix,
                                    '',
                                    settings)

    def __init__(self,
                 from_curr_dir: str,
                 from_top_level_file: str,
                 rendition_settings: RenditionSettings):
        Environment.__init__(self,
                             from_curr_dir,
                             from_top_level_file)
        self.rendition_settings = rendition_settings

    def render_file_name_according_to_settings(self, file_name):
        if rendition_settings.file_names_are_relative_file_argument_location:
            return self.file_name_relative_top_level_source_file(file_name)
        else:
            return self.file_name_relative_current_dir_of_process(file_name)


class ResultItem:
    """
    An item in a successful result, ready for rendering.

    The rendering is not allowed to raise exceptions related to
    the instruction that constructs this object.  I.e., all checks
    and parses must be done.
    """

    def render(self,
               env: RenditionEnvironment):
        """
        Renders the item as a string).

        Not allowed to raise exceptions (except for implementation issues,
        of course).
        """
        raise NotImplementedError()


class ResultItemsConstructor:
    """An iterable of ResultItem:s."""

    def result_item_iterable(self,
                             env: Environment):
        """
        Gives an iterable of all ResultItem:s that this object represents.

        Can raise exceptions related to parsing and file checking.
        """
        raise NotImplementedError()


class ResultItemForFile(ResultItem):
    """
    An result item that is a file name.
    """
    def __init__(self,
                 file_name: str):
        """
        file_name : the name of the file as specified in the source file -
        i.e. it is relative the source file.
        """
        self.file_name = file_name

    def render(self,
               env: RenditionEnvironment):
        debug('  ResultItemForFile : ' + self.file_name)
        debug("           env/fromTopLvl : " + env.fromTopLevelFile)
        debug("           env/fromCurrDir: " + env.fromCurrDir)
        return env.render_file_name_according_to_settings(self.file_name)


###############################################################################
# - Instruction:s -
###############################################################################


class InstructionApplicationException(Exception):
    """
    Indicates failure of an instruction to produce one of
    its ResultItem:s.
    """

    def __init__(self,
                 exit_code: int):
        self.exitCode = exit_code

    def render(self, o_stream):
        raise NotImplementedError()


class Instruction(ResultItemsConstructor):
    """
    Base class for instructions.

    An instruction produces an iterable of ResultItem:s.
    """

class File(ResultItemsConstructor):
    """A list of instructions in a single file."""

    def __init__(self,
                 instructions):
        self.instructions = instructions

    def result_item_iterable(self,
                             env: Environment):
        return ResultItemIterableForFile(self.instructions, env)


class ResultItemIterableForFile:
    def __init__(self,
                 instructions,
                 env: Environment):
        self.instructions = instructions
        self.env = env
        self.curr_result_item_iterable = None

    def __iter__(self):
        return self

    def __next__(self):
        while True:
            debug('    iter loop  : instructions.length = ' + str(len(self.instructions)))
            if self.curr_result_item_iterable is None:
                if not self.instructions:
                    debug('   iter stop')
                    raise StopIteration
                self.curr_result_item_iterable = self.instructions[0].result_item_iterable(self.env)
                del self.instructions[0]
            try:
                debug('       returning')
                return self.curr_result_item_iterable.__next__()
            except StopIteration:
                self.curr_result_item_iterable = None


###############################################################################
# - concrete instructions -
###############################################################################


class InstructionApplicationForMissingFileException(InstructionApplicationException):
    """
    Indicates that a referenced file does not exist.
    """

    def __init__(self,
                 file_name_relative_current_dir_of_process: str):
        InstructionApplicationException.__init__(self,
                                                 EXIT_FILE_DOES_NOT_EXIST)
        self.file_name_relative_current_dir_of_process = file_name_relative_current_dir_of_process

    def render(self, o_stream):
        write_lines(o_stream,
                    [
                        "File does not exist: " +
                        self.file_name_relative_current_dir_of_process
                    ])


class InstructionForFile(Instruction):
    """
    An instruction that resolves a single named file.
    """
    def __init__(self,
                 file_name: str):
        self.file_name = file_name 

    def result_item_iterable(self,
                             env: Environment):
        file_path = env.file_name_relative_current_dir_of_process(self.file_name)
        if not os.path.exists(file_path):
            raise InstructionApplicationForMissingFileException(file_path)
        result_item = ResultItemForFile(env.file_name_relative_top_level_source_file(self.file_name))
        return iter([result_item])


class InstructionForDirectoryListing(Instruction):
    """
    An instruction that resolves the contents of a directory.
    """
    def __init__(self, directory_name: str):
        self.directory_name = directory_name 

    def result_item_iterable(self,
                             env: Environment):
        dir_path = env.file_name_relative_current_dir_of_process(self.directory_name)
        if not os.path.isdir(dir_path):
            raise InstructionApplicationForMissingFileException(dir_path)
        env_for_dir = env.new_for_directory(self.directory_name)
        debug("list: " + self.directory_name)
        for fileInDir in os.listdir(dir_path):
            file_name_rel_curr_dir = env_for_dir.file_name_relative_current_dir_of_process(fileInDir)
            debug("list   " + fileInDir)
            debug("list   " + file_name_rel_curr_dir)
            if os.path.exists(file_name_rel_curr_dir):
                yield ResultItemForFile(
                    env_for_dir.file_name_relative_top_level_source_file(fileInDir))


class InstructionForForInclude(Instruction):
    """
    An instruction that resolves the contents of a list file.
    """
    def __init__(self,
                 file_name_relative_include_file: str):
        self.file_name_relative_include_file = file_name_relative_include_file

    def result_item_iterable(self,
                             env: Environment):
        file_path = env.file_name_relative_current_dir_of_process(self.file_name_relative_include_file)
        if not os.path.isfile(file_path):
            raise InstructionApplicationForMissingFileException(file_path)
        env_for_file = env.new_for_included_file(self.file_name_relative_include_file)
        debug("incl: " + self.file_name_relative_include_file)
        debug("         env/fromTopLvl : " + env_for_file.fromTopLevelFile)
        debug("         env/fromCurrDir: " + env_for_file.fromCurrDir)
        file_parser = FileParser(file_path)
        try:
            file = file_parser.apply(open(file_path,
                                          mode='r'))
        except OSError:
            raise InstructionApplicationForMissingFileException(file_path)
        return file.result_item_iterable(env_for_file)


###############################################################################
# - InstructionArgumentParser:s -
###############################################################################


class SourceInfo:
    """Information about a part of a file source."""
    def __init__(self,
                 file_name: str,
                 line_number: int,
                 line_contents: str):
        self.file_name = file_name
        self.line_number = line_number
        self.line_contents = line_contents

    def err_msg_file_ref(self):
        return "File \"" + self.file_name + "\", line " + str(self.line_number)


class InstructionSyntaxErrorException(Exception):
    """A syntactic error in an instruction of a source file."""
    def __init__(self,
                 source_info,
                 description):
        self.source_info = source_info
        self.description = description
    
    def render(self, o_stream):
        source_position = self.source_info.err_msg_file_ref()
        write_lines(o_stream,
                    [
                        source_position,
                        "  " + self.description + ":",
                        "    " + self.source_info.line_contents
                    ])


class InstructionLineSyntaxErrorException(InstructionSyntaxErrorException):
    """Invalid syntax of a line that should contain an instruction."""
    def __init__(self,
                 source_info):
        description = "Invalid input line, cannot find instruction:"
        InstructionSyntaxErrorException.__init__(self,
                                                 source_info,
                                                 description)


class InstructionNameSyntaxErrorException(InstructionSyntaxErrorException):
    """Invalid name of an instruction of a source file."""
    def __init__(self,
                 source_info: SourceInfo,
                 instruction_name: str):
        description = "Invalid instruction name `" + instruction_name + "'"
        InstructionSyntaxErrorException.__init__(self,
                                                 source_info,
                                                 description)


class InstructionArgumentSyntaxErrorException(Exception):
    """
    A syntactic error in an Instruction Option of a source file.

    This exception is internal to the File Parser and
    Option Parsers.
    
    This exception is raised by Option Parsers, and handled by
    the parser, which re-raises it in the form of a
    InstructionSyntaxErrorException.
    """
    def __init__(self,
                 message_lines: list):
        self._message_lines = message_lines

    def message_lines(self):
            return self._message_lines


class InstructionArgumentParser:
    """
    Parses the argument-part of a line in a source file.
    """

    def apply(self,
              instruction_argument: str):
        """Returns an Instruction."""
        raise NotImplementedError


class InstructionArgumentParserForFile(InstructionArgumentParser):
    """Parser for a single file."""

    def apply(self,
              instruction_argument: str):
        # TODO check syntax of instruction_argument - should be single
        # file name
        return InstructionForFile(instruction_argument)


class InstructionArgumentParserForDirectoryListing(InstructionArgumentParser):
    """Parser for the contents of a directory."""

    def apply(self,
              instruction_argument: str):
        # TODO check syntax of instruction_argument - should be single
        # file name
        return InstructionForDirectoryListing(instruction_argument)


class InstructionArgumentParserForInclude(InstructionArgumentParser):
    """Parser for including a file list."""

    def apply(self,
              instruction_argument: str):
        # TODO check syntax of instruction_argument - should be single
        # file name
        return InstructionForForInclude(instruction_argument)


###############################################################################
# - FileParser -
###############################################################################


class FileParser:
    """
    Parses a source file into a File object.
    """

    @staticmethod
    def for_top_level(file_name: str):
        return FileParser(file_name)

    parsers = {
        "FILE"    : InstructionArgumentParserForFile(),
        "LIST"    : InstructionArgumentParserForDirectoryListing(),
        "INCLUDE" : InstructionArgumentParserForInclude()
    }

    ignored_line_re_string = "^\s*(#.*)?$"
    ignored_line_re = re.compile(ignored_line_re_string)

    name_and_argument_groups_re_string = "\s*(\w+)\s*(.*)"
    name_and_argument_groups_re = re.compile(name_and_argument_groups_re_string)

    # Mutable state.
    # Having these here avoids having to pass them around to almost every
    # method.
    # The values are set by the top level method (apply), so that
    # can access them.
    # Only the apply method is allowed to modify this state.
    line_number = -1
    line = ""

    def __init__(self, file_name):
        self.file_name = file_name

    def apply(self, open_file):
        """
        Returns a File.
        """
        # Read all lines from the file so that we can close it before
        # opening any referenced files.
        # This prevents exhausting the number of open files.
        lines = open_file.readlines()
        open_file.close()

        self.line_number = 0
        instructions = []
        for lineWithPossibleNewLine in lines:
            self.line = lineWithPossibleNewLine.strip('\n')
            self.line_number += 1
            if self._is_ignored_line():
                continue
            instructions.append(self.parse_instruction_line())
        return File(instructions)

    def parse_instruction_line(self):
        (name, argument) = self._split_name_and_argument()
        try:
            parser = self.parsers[name]
            return parser.apply(argument)
        except KeyError:
            raise InstructionNameSyntaxErrorException(
                self._source_info(),
                name)

    def _split_name_and_argument(self):
        name_and_argument_match = re.search(self.name_and_argument_groups_re, self.line)
        if not name_and_argument_match:
            raise InstructionLineSyntaxErrorException(self._source_info())
        return (name_and_argument_match.group(1),
                name_and_argument_match.group(2))

    def _is_ignored_line(self):
        return self.ignored_line_re.match(self.line) is not None

    def _source_info(self):
        return SourceInfo(self.file_name,
                          self.line_number,
                          self.line)


###############################################################################
# - parse_command_line -
###############################################################################


def parse_command_line():
    """
    Returns an (file name,RenditionSettings,open file).
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("file",
                        metavar="FILE",
                        help="A file that contains the resolve specification.")
    parser.add_argument("--relative-file-argument-location", "-f",
                        default=False,
                        action='store_true',
                        help="File paths are relative the location of the FILE argument. Without this option, file names are relative the location of the invocation of the program.")
    args = parser.parse_args()
    rendition_settings = RenditionSettings(args.relative_file_argument_location)
    try:
        e = os.path.exists(args.file)
        return (args.file,
                rendition_settings,
                open(args.file,
                     mode='r'))
    except OSError:
        msg = "Cannot open file: \"" + args.file + "\""
        write_lines(sys.stderr,
                    [msg])
        sys.exit(EXIT_INVALID_ARGUMENTS)



###############################################################################
# - main -
###############################################################################


debug_begin('parse')
(file_name, rendition_settings, open_file) = parse_command_line()
debug_end('parse')
try:
    file = FileParser.for_top_level(file_name).apply(open_file)
    env = RenditionEnvironment.for_top_level_file(file_name, rendition_settings)
    debug_begin('iter')
    for resultItem in file.result_item_iterable(env):
        print(resultItem.render(env))
    debug_end('iter')

except InstructionSyntaxErrorException as ex:
    debug('InstructionSyntaxErrorException')
    ex.render(sys.stderr)
    sys.exit(EXIT_SYNTAX)

except InstructionApplicationException as ex:
    debug('InstructionApplicationException')
    ex.render(sys.stderr)
    sys.exit(ex.exitCode)
