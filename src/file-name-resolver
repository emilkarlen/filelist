#! /usr/bin/python3
# -*- coding: utf-8 -*-
# -*- python -*-

###############################################################################
# Copyright 2014 Emil Karl√©n.
# 
# This file is part of file-name-resolver.
# 
# Wilde is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Wilde is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Wilde.  If not, see <http://www.gnu.org/licenses/>.
###############################################################################


###############################################################################
# - parse arguments -
###############################################################################


import sys
import os
import argparse
import re

EXIT_USAGE = 2
EXIT_INVALID_ARGUMENTS = 3
EXIT_SYNTAX = 4
EXIT_FILE_DOES_NOT_EXIST = 8 + 0


###############################################################################
# - utilities -
###############################################################################


debugEnabled = False

def debug(s):
    if debugEnabled:
        print("DEBUG: ",s)

def debug_q(s):
    debug("\"" + s + "\"")

def write_lines(ostream,lines):
    """Writes a list of lines with an added trailing newline, to a stream."""
    for line in lines:
        ostream.write(line)
        ostream.write(os.linesep)


###############################################################################
# - classes -
###############################################################################


###############################################################################
# - ResultItem:s -
###############################################################################


class Environment:
    """
    Environment for executing instructions.
    """

    @staticmethod
    def forTopLevelFile(fileName):
        prefix = os.path.split(fileName)[0]
        if prefix:
            prefix = prefix + os.sep
        return Environment(prefix)

    def newForIncludedFile(self,nameOfIncludedFile):
        raise NotImplementedError # TODO remove if not used

    def __init__(self,fileNamePrefix):
        self.fileNamePrefix = fileNamePrefix

    def fileNameRelativeCurrentDirOfProc(self,fileName):
        return self.fileNamePrefix + fileName

    def fileNameRelativeTopLevelSourceFile(self,fileName):
        return fileName

class ResultItem:
    """
    An item in a successful result, ready for rendering.

    The rendering is not allowed to raise exceptions related to
    the instruction that constructs this object.  I.e., all checks
    and parses must be done.
    """

    def render(self,env : Environment):
        """
        Renders the item as a string).

        Not allowed to raise exceptions (except for implementation issues,
        of course).
        """
        raise NotImplementedError

class ResultItemsConstructor:
    """An iterable of ResultItem:s."""

    def resultItemIterable(self,env : Environment):
        """
        Gives an iterable of all ResultItem:s that this object represents.

        Can raise exceptions related to parsing and file checking.
        """
        raise NotImplementedError

class ResultItemForFile(ResultItem):
    """
    An result item that is a file name.
    """
    def __init__(self,fileName):
        """
        fileName : the name of the file as specified in the source file -
        i.e. it is relative the source file.
        """
        self.fileName = fileName

    def render(self,env : Environment):
        return env.fileNameRelativeCurrentDirOfProc(self.fileName)


###############################################################################
# - Instruction:s -
###############################################################################


class IntructionApplicationException(Exception):
    """
    Indicates failure of an instruction to produce one of
    its ResultItem:s.
    """

    def __init__(self,exitCode):
        self.exitCode = exitCode

    def render(self,ostream):
        raise NotImplementedError

class Instruction(ResultItemsConstructor):
    """
    Base class for instructions.

    An instruction produces an iterable of ResultItem:s.
    """
    def resultItemIterable(self,env : Environment):
        raise NotImplementedError

class File(ResultItemsConstructor):
    """A list of instructions in a single file."""

    def __init__(self,
                 directoryOfIncludingFile,
                 fileName,
                 instructions):
        """
        directoryOfIncludingFile is the empty string for top level files.
        """
        self.directoryOfIncludingFile = directoryOfIncludingFile
        self.fileName = fileName
        self.instructions = instructions

    def resultItemIterable(self,env : Environment):
        for instruction in self.instructions:
            for resultItem in instruction.resultItemIterable(env):
                yield resultItem


###############################################################################
# - concrete instructions -
###############################################################################


class IntructionApplicationForMissingFileException(IntructionApplicationException):
    """
    Indicates that a referenced file does not exist.
    """

    def __init__(self,fileNameRelativeCurrentDirOfProc):
        IntructionApplicationException.__init__(self,
                                                EXIT_FILE_DOES_NOT_EXIST)
        self.fileNameRelativeCurrentDirOfProc = fileNameRelativeCurrentDirOfProc

    def render(self,ostream):
        write_lines(ostream,
                    [
                        "File does not exist: " +
                        self.fileNameRelativeCurrentDirOfProc
                    ])

class InstructionForFile(Instruction):
    """
    An instruction that resolves a single named file.
    """
    def __init__(self,fileName):
        self.fileName = fileName 

    def resultItemIterable(self,env : Environment):
        filePath = env.fileNameRelativeCurrentDirOfProc(self.fileName)
        if os.path.exists(filePath):
            return [ResultItemForFile(self.fileName)]
        else:
            raise IntructionApplicationForMissingFileException(filePath)


###############################################################################
# - InstructionOptionParser:s -
###############################################################################


class SourceInfo:
    """Information about a part of a file source."""
    def __init__(self,
                 fileName,
                 lineNumber,
                 snippet):
        self.fileName = fileName
        self.lineNumber = lineNumber
        self.snippet = snippet

class InstructionSyntaxErrorException(Exception):
    """A syntactic error in an instruction of a source file."""
    def __init__(self,sourceInfo,description):
        self.sourceInfo = sourceInfo
        self.description = description
    
    def render(self,ostream):
        sourcePosition = "File \"" + self.sourceInfo.fileName + "\", line " + str(self.sourceInfo.lineNumber)
        write_lines(ostream,
                    [
                        sourcePosition,
                        "  " + self.description + ":",
                        "    " + self.sourceInfo.snippet
                    ])

class InstructionLineSyntaxErrorException(InstructionSyntaxErrorException):
    """Invalid syntax of a line that should contain an instruction."""
    def __init__(self,
                 sourceInfo):
        description = "The line contains no instruction."
        InstructionSyntaxErrorException.__init__(self,
                                                 sourceInfo,
                                                 description)

class InstructionNameSyntaxErrorException(InstructionSyntaxErrorException):
    """Invalid name of an instruction of a source file."""
    def __init__(self,
                 sourceInfo,
                 instructionName):
        description = "Invalid instruction name `" + instructionName + "'"
        InstructionSyntaxErrorException.__init__(self,
                                                 sourceInfo,
                                                 description)

class InstructionOptionSyntaxErrorException(Exception):
    """
    A syntactic error in an Instruction Option of a source file.

    This exception is internal to the File Parser and
    Option Parsers.
    
    This exception is raised by Option Parsers, and handled by
    the parser, which re-rases it in the form of a
    InstructionSyntaxErrorException.
    """
    def __init__(self,messageLines):
        self._messageLines = messageLines

    def messageLines(self):
            return self._messageLines

class InstructionOptionParser:
    """
    Parses the options-part of a line in a source file.
    """

    def apply(self,instructionOptions):
        """Returns an Instruction."""
        raise NotImplementedError

class InstructionOptionParserForFile(InstructionOptionParser):
    """Parser for a single file."""

    def apply(self,instructionOptions):
        # TODO check syntax of instructionOptions - should be single
        # file name
        return InstructionForFile(instructionOptions)


###############################################################################
# - FileParser -
###############################################################################


class FileParser:
    """
    Parses a source file into a File object.
    """

    @staticmethod
    def forTopLevel(fileName):
        return FileParser('',fileName)

    parsers = {
        "FILE" : InstructionOptionParserForFile()
    }

    ignoredLineReString = "^\s*(#.*)?$"
    ignoredLineRe = re.compile(ignoredLineReString)

    nameAndOptionGroupsReString = "\s*(\w+)\s*(.*)"
    nameAndOptionGroupsRe = re.compile(nameAndOptionGroupsReString)

    # Mutable state.
    # Having these here avoids having to pass them around to almost every
    # method.
    # The values are set by the top level method (apply), so that
    # can access them.
    # Only the apply method is allowed to modify this state.
    lineNumber = -1
    line = ""

    def __init__(self,directoryOfIncludingFile,fileName):
        """
        directoryOfIncludingFile : empty or ends with a dir-sepa.
        """

        self.directoryOfIncludingFile = directoryOfIncludingFile
        self.fileName = fileName
        self.outputLinePrefix = os.path.split(fileName)[0]

    def apply(self,openFile):
        """
        Returns a File.
        """
        # Read all lines from the file so that we can close it before
        # opening any referenced files.
        # This prevents exhausting the number of open files.
        lines = openFile.readlines()
        openFile.close()

        self.lineNumber = 0
        instructions = []
        for lineWithPossibleNewLine in lines:
            self.line = lineWithPossibleNewLine.strip('\n')
            self.lineNumber += 1
            if (self.__is_ignored_line()):
                continue
            instructions.append(self.parse_instruction_line())
        return File(self.directoryOfIncludingFile,
                    self.fileName,
                    instructions)

    def parse_instruction_line(self):
        (name,option) = self.__split_name_and_option()
        try:
            parser = self.parsers[name]
            return parser.apply(option)
        except KeyError:
            raise InstructionNameSyntaxErrorException(
                self.__sourceInfo(self.line),
                name)

    def __split_name_and_option(self):
        nameAndOptionMatch = re.search(self.nameAndOptionGroupsRe,self.line)
        if (not nameAndOptionMatch):
            raise InstructionLineSyntaxErrorException()
        return (nameAndOptionMatch.group(1),
                nameAndOptionMatch.group(2))

    def __is_ignored_line(self):
        return (self.ignoredLineRe.match(self.line) != None)

    def __sourceInfo(self,sourceSnippet):
        return SourceInfo(self.fileName,
                          self.lineNumber,
                          sourceSnippet)


###############################################################################
# - parse_command_line -
###############################################################################


def parse_command_line():
    """
    Returns an (file name,open file).
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("file",
                        metavar="FILE",
                        help="A file that contains the resolve specification.")
    args = parser.parse_args()
    try:
        debug('a')
        debug_q(os.getcwd())
        debug_q(sys.argv[0])
        debug_q(args.file)
        e = os.path.exists(args.file)
        debug("exists:" + str(e))
        return (args.file,
                open(args.file,mode='r'))
    except OSError:
        debug('b')
        msg = "Cannot open file: \"" + args.file + "\""
        write_lines(sys.stderr,
                    [msg])
        sys.exit(EXIT_INVALID_ARGUMENTS)



###############################################################################
# - main -
###############################################################################


(fileName,openFile) = parse_command_line()
try:
    debug('m1')
    file = FileParser.forTopLevel(fileName).apply(openFile)
    debug('m2')
    env = Environment.forTopLevelFile(fileName)
    debug('m3')
    for resultItem in file.resultItemIterable(env):
        print(resultItem.render(env))

except InstructionSyntaxErrorException as ex:
    ex.render(sys.stderr)
    sys.exit(EXIT_SYNTAX)

except IntructionApplicationException as ex:
    ex.render(sys.stderr)
    sys.exit(ex.exitCode)
